% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Xy.R, R/methods.Xy_sim.R
\name{Xy}
\alias{Xy}
\alias{print.Xy_sim}
\alias{coef.Xy_sim}
\alias{plot.Xy_sim}
\alias{transform.Xy_sim}
\title{Xy}
\usage{
Xy(n = 1000, numvars = c(2, 2), catvars = c(1, 2), noisevars = 5,
  task = Xy_task(), nlfun = function(x) x^2, interactions = 1,
  sig = c(1, 10), cor = c(0, 0.1), weights = c(5, 10), sigma = NULL,
  stn = 4, noise.coll = FALSE, intercept = TRUE)

\method{print}{Xy_sim}(x, ...)

\method{coef}{Xy_sim}(object, ...)

\method{plot}{Xy_sim}(x, ...)

\method{transform}{Xy_sim}(`_data`, ...)
}
\arguments{
\item{n}{an integer specifying the number of observations}

\item{numvars}{a numeric vector specifying the number of linear and nonlinear
X For instance, \code{c(5, 10)} corresponds to
five linear and ten non-linear X.}

\item{catvars}{a numeric vector determining the amount of categorical predictors.
With this vector you can choose how many categorical predictors should
enter the equation and secondly the respective amount of categories.
For instance, \code{catvars = c(2,5)} would correspond to creating
two categorical variables with five categories.}

\item{noisevars}{an integer determining the number of noise variables}

\item{task}{a Xy task object as created with \code{\link{Xy_task}}}

\item{nlfun}{a function transforming nonlinear variables}

\item{interactions}{a vector of integer specifying the interaction depth of
of regular X and autoregressive X if
applicable.}

\item{sig}{a vector c(min, max) indicating the scale parameter to sample from}

\item{cor}{a vector c(min, max) determining correlation to sample from.}

\item{weights}{a vector c(min, max) specifying 
the multiplication magnitude to sample from}

\item{sigma}{a covariance matrix for the linear and nonlinear simulation.
Defaults to \code{NULL} which means the structure
will be sampled from \code{cor}}

\item{stn}{an integer value determining the signal to noise ratio.
Higher values lead to more signal and less noise.}

\item{noise.coll}{a boolean determining noise collinearity with X}

\item{intercept}{a boolean indicating whether an intercept should enter the model}

\item{x}{an object of class \code{Xy_sim}.}

\item{...}{arguments to be passed to methods}

\item{object}{an object of class \code{Xy_sim}.}

\item{_data}{an object of class \code{Xy_sim}.}
}
\value{
a list with the following entries
\itemize{
\item \code{data} - the simulated data.table
\item \code{tgp} - the target generating process as a string
\item \code{psi} - psi is a transformation matrix which transforms the raw data
                   (stored in $data) to the true effects. However, you have to
                   apply the nonlinear functions upfront. If you want to transform
                   the data, please use \code{\link{transform}}
\item \code{control} - a list matching the call
}
}
\description{
A function which simulates linear and nonlinear X and a corresponding
target. The composition of the target is highly customizable.
Furthermore, the polynomial degree as well as the functional shape of
nonlinearity can be specified by the user. Additionally coviarance structure
of the X can either be sampled by the function or specifically 
determined by the user.
}
\examples{

set.seed(1337)
my_simulation <- Xy()

# Get a summary of your simulation
print(my_simulation)

# Extracting the weights
coef(my_simulation)
# Plotting the true underlying effects
plot(my_simulation)
# Getting the true underlying data of the process
transform(my_simulation)
}
\author{
Andre Bleier (\email{andre.bleier@statworx.com})
}
